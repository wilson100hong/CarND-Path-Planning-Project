# CarND-Path-Planning-Project
Self-Driving Car Engineer Nanodegree Program

---

[//]: # (Image References)

[image1]: ./images/youtube.png "Youtube"

---

## Basic Build Instructions

1. Clone this repo.
2. Make a build directory: `mkdir build && cd build`
3. Compile: `cmake .. && make`
4. Run it: `./path_planning`.

## Dependencies

* cmake >= 3.5
  * All OSes: [click here for installation instructions](https://cmake.org/install/)
* make >= 4.1
  * Linux: make is installed by default on most Linux distros
  * Mac: [install Xcode command line tools to get make](https://developer.apple.com/xcode/features/)
  * Windows: [Click here for installation instructions](http://gnuwin32.sourceforge.net/packages/make.htm)
* gcc/g++ >= 5.4
  * Linux: gcc / g++ is installed by default on most Linux distros
  * Mac: same deal as make - [install Xcode command line tools]((https://developer.apple.com/xcode/features/)
  * Windows: recommend using [MinGW](http://www.mingw.org/)
* [uWebSockets](https://github.com/uWebSockets/uWebSockets)
  * Run either `install-mac.sh` or `install-ubuntu.sh`.
  * If you install from source, checkout to commit `e94b6e1`, i.e.
    ```
    git clone https://github.com/uWebSockets/uWebSockets 
    cd uWebSockets
    git checkout e94b6e1
    ```

## Project Rubrics

### The car is able to drive at least 4.32 miles without incident.
The car can drive more than 10+ miles without incident from simulation on my machine.
However, since vehicles traffic is not deterministic, my experiments may not cover 100% cases.

### The car drives according to the speed limit.
The car drives around `MAX_SPEED` 21.5 m/s (~48.09413 mph) with +/- 0.2 m/s, which is less than the hard limit 22.352 m/s (50 mph).

### Max Acceleration and Jerk are not Exceeded.
During simulation, max jerk < 5 m/s^3, and max acceleration < 5 m/s^3. Both are under the limits.
This is done by limit the distance between adjacent waypoints in trajectory based on the car's current speed and target speed. See `planner.h` line 350 ~ 365.

### Car does not have collisions.
The car does not collide with other vehicles:
- Car detects if there is any front vehicle in same lane closer than 43 m (distance driving 2 seconds in max speed). If so, ego_car will slow down to the same speed as the front vehicle and keep following without colliding with it.
- When car prepares the change lane, it will make sure the candidate lane is "clear enough" to make lane changing without colliding vehicle in front or crash by rear vehicle. This is done by comparing the vehicles' speed and s-value on candidate lane with ego car. See `planner.h` `CanChangeLane()` line 391. 

### The car stays in its lane, except for the time between changing lanes.
The car follows the reference line in `KEEP_LANE` state. The reference line is created by fitting a pline to the waypoints provided by map. Waypoints are s-value `30` apart; the value is picked to make psline smooth enough while handles sharp turn well.

### The vehicle must successfully drive a lap around the track.
The simulation result shows the vehicle is stayed on drivable area. At some sharp turns it will infringe the curb lanes but still keep on track.

### The car is able to change lanes
The car will prepare to change lane when its target speed (maximum speed without collision) is less than a threshold `MIN_SPEED` (21.5 m/s, a little less than `MAX_SPEED`). It will create trajectories by trying change to candidate lane. If the trajectory is feasible (no collision) and has less cost than current lane, it will execute lane changing.

The cost is a function to measure the performance of a trajectory, the lower the better. It considers
- speed cost: the higher speed, the lower cost.
- traveled distance: the more distance traveled (s-value advanced), the lower cost.  
- lane cost: center lane (lane = 1) is prefereed when other cost is close. If speed and distance are almost the same, driving in the middle lane provides the most flexibility in lane changing.


## Trajectory Generation (a.k.a. path generation)
Trajectory is generated by class `Planner`. It keeps the current state and the lane it should track. In every cycle,
it uses the previous trajectory, ego car status and sensor fusion to create the best trajectory.

1. Truncate the previous trajectory to `STITCH_SIZE`. This are waypoints to initalize new trajectory. `STITCH_SIZE = 50` means it will keep at most 50 points.

2. Find "target speed" of the tracked lane. Target speed is the maximum speed ego car can achieve without violating speed limit and causing collisions. Target speed is decided by the closest in-front vehicle is closer enough.

3. Create trajectory from previous truncated trajectory (derived in 1.), tracked lane, target speed and ego car status:

   3.1. Create the reference line, Reference line is composed of 5 points in the order
   - The last two points from previous truncated trajectory.
   - Additional 3 (`NUM_REF_STEP`) points with step distance 30.0 (`REF_STEP_S`).

   3.2. Convert points in reference line in the coordinate of end pose (last pose from previous truncated trajectory).

   3.3. Fits the reference line to a spline so its smoother. 

   3.4. Fill waypoints to traectory until it has 50 points. For each point, we calculate the best speed it can achieve without violating the target speed, acceleration limit and jerk limit. This is done by keep incrementing the speed until hits target speed. Multiplying the best speed with delta timestamp 0.02 (`DELTA_T`) we can get the distance moved on the spline. Projects the distance on x-axis with an approximate angle we can get the (x', y') on spline (in the end pose's coodinate). Convert it to world coordinates and add to the trajectory.

   See `planner.h` line 340 ~ 365.

4. If planner state is `LANE_CHANGING` state, just return the trajectory derived from 3. since we don't want to consider other lanes before completing lane change. DONE.

5. If planner state is `KEEP_LANE` and target speed is good enough, just return the trajectory derived from 3. DONE.

6. Otherwise, we need to prepare lane changing. We will create trajectories for left and right candidate lanes (`track_lane-1` and `track_lane+1`). We only consider candidate lane when lane changing is safe (no collision is caused). This is done by make sure no other vehicle is in a safety region, defined by ego car's position and speed.

7. Select the best trajectory from candidates which has the lowest cost. It gives the best combination of speed, distance traveled and lane flexibility.

8. Update planner's state: change state to `LANE_CHANGING` if the best trajectory's candidate lane is different from current tracked lane.

9. Returns the best trajectory. DONE.


## Video
[YouTube video](https://youtu.be/4e3U17itUlE)

![Screenshot][image1]
